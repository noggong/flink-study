# 3장 아파치 플링크 아키텍쳐
## 시스템 아키텍처
- 플링크는 상태가 있는 병렬 스트림을 처리할 수 있는 분산 시스템
- 기존 클러스터 인프라와 서비스를 이용
	- 클러스터 : 아파치 메소스, YARN, 쿠버네티스, 독립형
	- 저장소 : HDFS, S3
	- 리더 선출 : 주키퍼
- ### 플링크 컴포넌트
	- #### 잡매니저
		- 애플리케이션의 실행을 제어하는 마스터 프로세스
		- 체크 포인트를 조율
		- 잡그래프 (논리데이터플로우)와 필요한 모든 클래스 라이브러리, 기타자원을 포함 하는 JAR →
		- 잡그래프를 실행그래프라 부르는 물리데이터 플로우로 변환 →
		- 리소스 매니저에게 자원 요청 →
		- 태스크로 실행 그래프를 배포
	- #### 리소스매니저
		- 플링크의 실행 단위인 태스크매니저 슬롯을 관리하는 책임
		- 유휴슬롯을 잡매니저에게 제공하도록 태스크매니저에게 지시
	- #### 태스크매니저
		- 워커 프로세스 : 여러 슬롯을 제공
		- 자신의 모든 슬롯을 리소스 매니저에 등록
		- JVM 프로세스안에서 멀티스레드로 태스크 실행
	- #### 디스패처
		- 여러 잡을 실행할 때 사용
		- 애플리케이션을 제출할 수 있는 Rest 인터페이스 제공
		- 잡매니저를 시작하고
		-  애플리케이션을 잡 매니저에 넘김
	- ![[스크린샷 2025-02-18 오전 10.38.37.png]]
- ### 애플리케이션 배치
	- #### 프레임워크 방식
		- 애플리케이션을 하나의 JAR 파일을 실행 중인 서비스중 하나로 제출  
			- 서비스: 디스패처, 플링크 디스패처, 플링크 잡매니서, YARN
	- #### 라이브러리 방식
		- 특화된 컨테이너 이미지 (ex: 도커) 생성
- ## 태스크 실행
	- C, E 의 병렬값 : 2 / 다른 연산자의 병렬 값 : 4
		- ![[스크린샷 2025-02-18 오전 10.52.52.png]]
	- 태스크가 동일한 태스크매니저에 할당시 : 네트웍 비용 ↓ / 부하 ↑
	- ==하나의 태스크매니저에 하나의 슬롯을 설정== 
		- ==태스크매니저 장애 전파 막는다==
		- ==호스트 하나에 여러 태스크매니저를 배치==
		- ?? 1개의 호스트 > 여러 태스크매니저 > 하나의 slot
- ### 고가용성 설정
	- #### 태스크매니저 실패
		- 리소스매니저에게 충분한 양의 처리 슬롯을 요구
		- 잡매니저는 충분한 슬롯을 확보 할 수 있을때까지 재시작 할수 없다.
		- 
	- 잡매니저 실패
		- 단일 실패 지점
		- 다른 잡 매니저로 책임과 메타데이터를 넘기는 고가용성 기능을 제공
		- 주키퍼 : 조율과 합의 기능을 분산서비스로 제공한다.
		- 고가용성 모드로 운영시 잡매니저는 잡그래프와 애플리케이션 JAR 파일처럼 필수 메타데이터를 원격의 영구 저장 시스템에 저장
		- ![[스크린샷 2025-02-18 오전 10.38.37.png]]
## 플링크 내부의 데이터 전송 
- 버퍼에 배치로 모여서 전송 
	- 기본 버퍼풀 : 32kb
- 셔플 연결 패턴 
	- 각각 전송 → 수신
- ![[스크린샷 2025-02-18 오전 11.16.12.png]]
- ### 크레딧 기반 흐름 제어
	- 크레딧 ? 수신 테스크가 데이터를 수신하려고 예약한 네트워크 버퍼갯수
	- 백로그 크기 : 가득차서 전송할 준비가 된 네트워크 버퍼수
	- 수신 태스크 크래딧을 전송 태스크에 알려줌 → 크레딧만틈의 버퍼와 백로그 크기를 수신테스크에 전송 → 수신은 백로그 크기를 기반으로 다음 태스크를 결정
- ### 태스크 체이닝
	- 로컬 통신의 부하를 줄여주기 위해, 모든 연산 함수를 태스크 하나에 합쳐 실행하고, 각 테스크를 스레드 하나에서 실행
	- ![[스크린샷 2025-02-18 오전 11.28.18.png]] →![[스크린샷 2025-02-18 오전 11.28.34.png]]
## 이벤트 시간 처리
- ### 타임 스탬프
- ### 워터마크
	- Watermark`는 "지금까지 도착한 데이터에서 믿을 수 있는 가장 늦은 시간"을 의미