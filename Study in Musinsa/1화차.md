---
UP:
  - "[[1️⃣ Figurehead]]"
  - "[[1️⃣ Musinsa]]"
  - "[[2️⃣ Engineering]]"
github: https://github.com/streaming-with-flink/examples-java
---
# 스터디 주제
**1회차: 플링크 소개 및 핵심 개념 학습**

- **이론**: "아파치 플링크로 하는 스트림 데이터 처리" 책의 **1장** 내용을 중심으로 학습.
    - 스트림 데이터 처리의 기본 개념과 플링크의 특징, 아키텍처 소개.
    - **플링크의 핵심 설계 철학인 "배치는 데이터가 유한한 스트림이다"** 에 대한 이해.
    - **마이크로서비스 아키텍처**와 플링크의 연관성 학습.
    - **스트림 처리와 배치 처리**의 차이점 이해.
    - **상태가 있는 스트림 처리**의 중요성 학습.
- **실습**: 간단한 로컬 플링크 클러스터 환경 설정 및 실행.
- **참고**: 아파치 플링크 공식 문서 "Getting Started" 섹션 ([https://nightlies.apache.org/flink/flink-docs-stable/docs/try-flink/local_installation/](https://nightlies.apache.org/flink/flink-docs-stable/docs/try-flink/local_installation/)).
[[1회차 - chat gpt]]
---**[1회차 퀴즈](https://wiki.musinsa.com/display/datasvc/03.01+Quiz)****가 준비** 되었습니다. 함께 풀어보세요~! (위키 참고)**1주차 퀴즈 (심화 및 스파크 비교 포함)**  

1. 아파치 플링크의 핵심 설계 철학은 무엇이며, 이를 통해 배치 처리를 어떻게 이해할 수 있나요?
2. 스트림 처리와 배치 처리의 주요 차이점은 무엇인가요?
3. 상태가 있는 스트림 처리가 왜 중요한가요?
4. 마이크로서비스 아키텍처에서 아파치 플링크는 어떤 역할을 할 수 있을까요?
5. 플링크에서 제공하는 데이터 처리 방식에는 어떤 것이 있나요?

**심화 문제**  

1. 플링크는 "상태가 있는 스트림 처리"를 완벽하게 구현했다고 평가받고 있습니다. 상태 관리 측면에서 플링크의 강점은 무엇이며, 다른 스트림 처리 기술과 비교했을 때 어떤 차이가 있을까요?
2. 플링크는 "이벤트 시간"이라는 개념을 도입하여 데이터 처리의 정확성을 높입니다. 이벤트 시간과 처리 시간의 차이점은 무엇이며, 각각 어떤 상황에서 유용하게 사용될 수 있을까요?
3. 플링크의 "워터마크"는 이벤트 시간 윈도우에서 중요한 역할을 합니다. 워터마크의 개념과 기능을 설명하고, 워터마크를 너무 빠듯하게 또는 너무 느슨하게 설정했을 때 발생할 수 있는 문제점을 설명해 보세요.

**스파크와의 차이점**  

1. 아파치 스파크와 아파치 플링크는 모두 널리 사용되는 데이터 처리 프레임워크입니다. 두 프레임워크의 설계 철학 및 스트림 처리 방식에 대한 주요 차이점을 설명하고, 각 프레임워크가 어떤 유형의 애플리케이션에 더 적합한지 토론해 보세요.


# 개인 정리
Stream 이란?
- 실시간 거의 준실시간 으로 생성되는 데이터의 연속적인 흐름을 의미 
	- [[실시간 데이터 처리 위한 Spark & Flink & Kafka#^a475b4]]
- 연속 적인 데이터 흐름 : 데이터는 고정된 파일 단위가 아니라 지속적으로 발생
	- ![[스크린샷 2025-01-13 오후 9.07.35.png]]
- Stream 의 주요 해결 포인트
	- Out-of-order
	- Late event
	- Stateful processing
	- Real-time processing
	- Fault tolerance
	- Scalability
	- Integration with other Systems
- Operator : 스트림 파이프라인을 구성하는 기본 구조, 빌딩 블록
- ![[스크린샷 2025-01-13 오후 9.02.37.png]]
	- ==파란색 : 긍정 /  주황 : 부정 / 노랑 : 대체로 긍정 이지만 다른 Tool 에 비해서 약함 ==
- ## 데이터 처리 방식
	- ###  상태 기반 처리
		- key 는 들어오는 streams 을 가상 (논리적으로) 으로 partitioning 방식
		- 상태를 전체적으로 공유 하고 관리하는 방식은 Flink 의 체크포인트 와 [[상태 백엔드 (backend state)]]  를 통해 구현
	- ### 이벤트 시간 처리 / 처리시간 처리
	- #### **1. 처리 시간(Processing Time)**
		- **처리 시간**은 데이터가 **Flink 작업에서 처리되는 시점의 시스템 시간**을 기준으로 동작합니다. 이는 이벤트가 발생한 실제 시간과는 무관하며, 데이터를 처리하는 시스템의 현재 시간을 기준으로 윈도우를 종료하거나 트리거합니다.
		- ##### **특징:**
			- **빠른 구현:** 데이터를 처리하는 시스템의 현재 시간만 필요하므로 추가적인 타임스탬프 처리나 워터마크 설정이 필요하지 않습니다.
			- **간단함:** 데이터가 순서에 상관없이 처리되어도 문제없습니다.
			- **시간 왜곡 가능:** 데이터 처리 속도가 변하면 윈도우 경계가 예상과 다르게 작동할 수 있습니다.
			- **실시간 처리:** 데이터 도착과 동시에 처리하는 경우 유용합니다.
		- #### **예시 시나리오:**
			- 실시간 모니터링 시스템 (예: 웹 서버 로그 분석).
			- 이벤트 시간 정보가 필요 없는 간단한 스트리밍 처리.
	- ### 이벤트 시간(Event Time)
		- ****이벤트 시간**은 데이터 이벤트가 발생한 실제 시간을 기준으로 동작합니다. 이벤트에 포함된 타임스탬프를 사용하여 데이터를 처리하며, 이벤트 순서가 엉키거나 지연된 데이터를 처리하는 데 적합합니다.
		- ##### **특징:**
			- **정확성:** 이벤트 발생 시간에 따라 처리되므로, 지연 데이터나 순서가 뒤섞인 데이터도 적절히 처리할 수 있습니다.
			- **복잡성:** 타임스탬프 추출과 워터마크 설정이 필요합니다.
			- **지연 처리 허용:** 워터마크를 통해 지연된 데이터를 허용할 수 있습니다.
			- **재현 가능성:** 동일한 데이터로 동일한 결과를 보장합니다.
		- ##### **예시 시나리오:**
			- IoT 센서 데이터 분석 (예: 온도, 습도 센서).
			- 로그 데이터 처리 (예: 사용자의 클릭 이벤트).
			- 비디오 스트리밍 분석 (예: 광고 효과 측정).
- ### 윈도우 처리 (워터마크)
- ### Checkpoint와 Savepoint의 차이점

- **Checkpoint**:
    
    - Flink가 자동으로 주기적으로 생성.
    - 장애 복구를 위한 용도로 사용.
    - 작업이 종료되면 삭제될 수 있음.
- **Savepoint**:
    
    - 사용자가 명시적으로 생성.
    - 작업 재배포, 업그레이드 시 사용.
    - 사용자가 관리하고 보관해야 함.